<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>module_asrc &mdash; Documentation  documentation</title>
    <link rel="stylesheet" href="_static/xdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/xcomment.js"></script>
    <link rel="top" title="Documentation  documentation" href="index.html" />
    <link rel="prev" title="Using FIR filters" href="fir.html" /> 

<script>
function setheight() {
h1 = document.getElementById('d1').style.height;
h2 = document.getElementById('d2').style.height;

if (parseInt(h1) > parseInt(h2)) {
document.getElementById('d2').style.height=h1 + "px";
}
else {
document.getElementById('d1').style.height=h2 + "px";
}

}
</script>
</head>

<body onload="setheight();">

  

    <div class="document" id='d1'>
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
<div style="float: right">
<a href="fir.html"
                        title="previous chapter"> &lt&lt </a>
</div>

            
  <div class="section" id="module-asrc">
<h1>module_asrc<a class="headerlink" href="#module-asrc" title="Permalink to this headline">¶</a></h1>
<p>The Asynchronous Sample Rate converter is capable of deleting or inserting
samples in arbitrary places in the input stream. This operation can be used
when an incoming signal has to be synchronised with a local clock.
By nature this operation introduces harmonic distortion that can be
minimised by setting the filter to a high upsampling rate and high order.</p>
<p>There are two interfaces to the ASRC module. The first interface is a
simple interface that manages the deletion and insertion of samples at
arbitrary places. After initialisation, a single function <tt class="docutils literal"><span class="pre">asrcFilter()</span></tt>
is called that takes care of buffer management and interpolation.</p>
<p>The second interface is slightly more complex but enables continuous
interpolation of a signal; but buffer management has to be taken care of by
the caller: <tt class="docutils literal"><span class="pre">asrcContinuousBuffer()</span></tt> adds a sample to the buffer
and <tt class="docutils literal"><span class="pre">asrcContinuousInterpolate()</span></tt> interpolates a sample given a
fractional position. The fractional position is a number between 0 and 1
inclusive. If, for example, the stream is too fast, the caller will
increase the fractional position gradually, and when it reaches 1 an extra
sample should be added to the buffer, and the fractional position be reset
to 0. Similarly, rather than decreasing the fractional position to below
zero, it should wrap back to 1 and an extra interpolation should take place.</p>
<div class="section" id="general-api">
<h2>General API<a class="headerlink" href="#general-api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="configuration-defines">
<h3>Configuration defines<a class="headerlink" href="#configuration-defines" title="Permalink to this headline">¶</a></h3>
<p><strong>ASRC_ORDER</strong></p>
<blockquote>
<div>This sets the number of samples over which to smooth the signal. A
higher value creates less audible artefacts, but increases latency and
computational requirements linearly. Must be a power of 2 to simplify
buffer management.</div></blockquote>
<p><strong>ASRC_UPSAMPLING</strong></p>
<blockquote>
<div>This sets the number of steps over which the lost/added sample is
generated. The filter can only insert or delete a sample once during
the upsampling period. The higher the value, the lower the noise floor.
Higher values require more memory (the coefficient array is of size
ASRC_ORDER * ASRC_UPSAMPLING). ASRC_UPSAMPLING should be a power of 2
in order to simplify the fractional sample location used by
<tt class="docutils literal"><span class="pre">asrcContinuousInterpolate()</span></tt></div></blockquote>
<p>The default values for <tt class="docutils literal"><span class="pre">ASRC_ORDER</span></tt> and <tt class="docutils literal"><span class="pre">ASRC_UPSAMPLING</span></tt> are 8
and 128. For each combination a table of coefficients is required. Tables
are defined as part of the module (in <tt class="docutils literal"><span class="pre">coeffs.xc</span></tt>) for the following combinations:</p>
<ul class="simple">
<li>4 and 256</li>
<li>4 and 128</li>
<li>8 and 128</li>
<li>8 and 64</li>
<li>16 and 64</li>
</ul>
<p>To support other combinations, compute the coefficients for a
low-pass FIR filter (using the <tt class="docutils literal"><span class="pre">makefir</span></tt> program in this repo) with the
following parameters:</p>
<ul class="simple">
<li>Corner frequency: -low <tt class="docutils literal"><span class="pre">1</span></tt></li>
<li>Sampling rate: -fs <tt class="docutils literal"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">ASRC_UPSAMPLING</span></tt></li>
<li>Number of taps: -n <tt class="docutils literal"><span class="pre">ASRC_UPSAMPLING</span> <span class="pre">*</span> <span class="pre">ASRC_ORDER</span> <span class="pre">+</span> <span class="pre">1</span></tt></li>
<li>Scale value: -one <tt class="docutils literal"><span class="pre">16777216</span> <span class="pre">*</span> <span class="pre">ASRC_UPSAMPLING</span></tt></li>
</ul>
<p>Delete the second half of the generated values, (the filter will be
symmetrical) so that you are left with <tt class="docutils literal"><span class="pre">(ASRC_UPSAMPLING</span> <span class="pre">*</span> <span class="pre">ASRC_ORDER)/2</span> <span class="pre">+</span>
<span class="pre">1</span></tt> coefficients, and so that the last value of the array is <tt class="docutils literal"><span class="pre">16777216</span></tt>.
Add this array to an appropriate <tt class="docutils literal"><span class="pre">#elif</span></tt> in <tt class="docutils literal"><span class="pre">coeffs.xc</span></tt></p>
</div>
<div class="section" id="types">
<h3>Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="asrcState">
<tt class="descname">asrcState</tt><a class="headerlink" href="#asrcState" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure that is used to store the state of the converter.</p>
<p>One structure should be declared for each channel that the converter is executed on. The internals of this structure are relevant only inside the converter and should not be relied upon by the caller.</p>
<p><strong>Structure Members:</strong></p>
<dl class="member">
<dt id="asrcState.wr">
int <tt class="descname">wr</tt><a class="headerlink" href="#asrcState.wr" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>points one above the last value written  ::</dt>
<dd>Current index in historic sample value,</dd>
</dl>
</dd></dl>

<dl class="member">
<dt id="asrcState.firStart">
int <tt class="descname">firStart</tt><a class="headerlink" href="#asrcState.firStart" title="Permalink to this definition">¶</a></dt>
<dd><p>The first point of the FIR to use.</p>
</dd></dl>

<dl class="member">
<dt id="asrcState.state">
int <tt class="descname">state</tt><a class="headerlink" href="#asrcState.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Inserting, Deleting, or Neither.</p>
</dd></dl>

<dl class="member">
<dt id="asrcState.buffer">
int <tt class="descname">buffer</tt><a class="headerlink" href="#asrcState.buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>historic sample values</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="asrcInit">
void <tt class="descname">asrcInit</tt><big>(</big>struct <a class="reference internal" href="#asrcState" title="asrcState"><span>asrcState</span></a><em>&nbsp;&amp;state</em><big>)</big><a class="headerlink" href="#asrcInit" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that initialises the asynchronous sample rate converter.</p>
<p>This resets the state and should be called once for each  declared.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>state</strong> &#8211; buffer structure containing past sample values for interpolation</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="simple-api">
<h2>Simple API<a class="headerlink" href="#simple-api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>Functions<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="asrcFilter">
int <tt class="descname">asrcFilter</tt><big>(</big>int<em>&nbsp;sample</em>, int<em>&nbsp;diff</em>, struct <a class="reference internal" href="#asrcState" title="asrcState"><span>asrcState</span></a><em>&nbsp;&amp;state</em><big>)</big><a class="headerlink" href="#asrcFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that produces a new sample, possibly interpolating.</p>
<p>To be called on every sample. Set the parameter  to -1 or +1 to indicate that a sample is to be deleted or inserted. Anytime that this function is called with a request to delete or insert a sample, at least ASRC_UPSAMPLING+1 calls should be made with  set to 0 for the interpolation to complete.</p>
<p>When  is -1, the return value of the function should be ignored, this accounts for the deleted sample. When  is +1, the input sample to the function will be ignored, this accounts for the inserted sample.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sample</strong> &#8211; current sample value. Ignored if  is +1.</li>
<li><strong>diff</strong> &#8211; value to indicate that a sample shall be deleted or inserted from the stream. When -1, a value shall be deleted and the return value of this function should be ignored. When +1 a value shall be inserted into the stream, and the sample passed into the function will be ignored.</li>
<li><strong>state</strong> &#8211; buffer structure containing past sample values for interpolation</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an interpolated sample value. To be ignored if  is -1.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="example">
<h3>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h3>
<p>A simple example reclocks an input stream to a given wordclock. The
assumption are that both input stream and wordclock are stable, and almost
the same frequency. A sample is added or deleted when the stream runs out
of sync too far with the word clock</p>
<div class="highlight-none"><div class="highlight"><pre>#define MAXDIFF 4

// This example is untested... Ought to be...
void reclockExample(port inLRclk, chanend inSlave, chanend outSlave) {
    struct asrcState asrcState;
    int sample, v;
    int diff = 0;
    int lr = 0;
    asrcInit(asrcState);
    while(1) {
        select {
        case inLRclk when pinsneq(lr) :&gt; lr:
            if (lr) {
                if (diff &gt; MAXDIFF) {                   // Difference too large - add a sample in other stream.
                    v = asrcFilter(0, 1, asrcState);
                    outSlave &lt;: v;
                } else {
                    diff++;
                }
            }
            break;
        case inSlave :&gt; sample:
            if (diff &lt; -MAXDIFF) {                     // Difference too large - remove a sample in this stream.
                (void) asrcFilter(sample, -1, asrcState);
            } else {
                v = asrcFilter(sample, 0, asrcState);
                outSlave &lt;: v;
                diff--;
            }
            break;
        }
    }
}
</pre></div>
</div>
<p>A more complex example has two input streams, and it will delete a sample
on either stream when it runs ahead too far.</p>
<div class="highlight-none"><div class="highlight"><pre>#define MAXDIST 4

// This example is untested... Ought to be...
void twoStreamExample(chanend inMaster, chanend inSlave, chanend outMaster, chanend outSlave) {
    struct asrcState asrcState;
    int sample, v;
    int diff = 0;
    asrcInit(asrcState);
    while(1) {
        select {
        case inMaster :&gt; sample:
            outMaster &lt;: v;
            if (diff &gt; MAXDIST) {                   // Difference too large - add a sample in other stream.
                v = asrcFilter(0, 1, asrcState);
                outSlave &lt;: v;
            } else {
                diff++;
            }
            break;
        case inSlave :&gt; sample:
            if (diff &lt; -MAXDIST) {                  // Difference too large - remove a sample in this stream.
                (void) asrcFilter(sample, -1, asrcState);
            } else {
                v = asrcFilter(sample, 0, asrcState);
                outSlave &lt;: v;
                diff--;
            }
            break;
        }
    }
}
</pre></div>
</div>
</div>
<div class="section" id="performance">
<span id="sc-dsp-filters-asrc-performance"></span><h3>Performance<a class="headerlink" href="#performance" title="Permalink to this headline">¶</a></h3>
<p>The filtering function performs a low pass filter when inserting or
deleting, which requires computation linear in ASRC_ORDER. As an
indication, when ASRC_ORDER = 4, the worst case execution path is a double
call to the filter function (to delete a sample), this takes 170 thread
cycles or 3.4 us at 50 MIPS. This worst case is guaranteed to happen
only once per deleted sample, and typical performance when filtering is 110 thread cycles or
2.2 us at 50 MIPS. Hence, if this function is called just prior to
delivering an audio sample in a 48 kHz stream, then a single thread at 50
MIPS can filter around 6 streams at 48 kHz, or 3 streams at 96 kHz. If used
in a system with a small buffer, 9 streams can be processed at 48 kHz.</p>
</div>
<div class="section" id="distortion">
<h3>Distortion<a class="headerlink" href="#distortion" title="Permalink to this headline">¶</a></h3>
<p>Below we show the frequency analysis of a 1kHz sinewave that has been
sped up using the Asynchronous Sample Rate converter with
upsampling rates of between 64 and 250, and filters of orders 4, 8, and 16.
This experiment used a 48 kHz sample rate at 24 bits. Note that order 4
will be sufficient for many applications.</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/100ppm-256-s.png"><img alt="_images/100ppm-256-s.png" src="_images/100ppm-256-s.png" style="width: 100%;" /></a>
<p class="caption">conversion to slightly faster clock, 256 x upsampling</p>
</div>
<div class="figure">
<a class="reference internal image-reference" href="_images/100ppm-128-s.png"><img alt="_images/100ppm-128-s.png" src="_images/100ppm-128-s.png" style="width: 100%;" /></a>
<p class="caption">conversion to slightly faster clock, 128 x upsampling</p>
</div>
<div class="figure">
<a class="reference internal image-reference" href="_images/100ppm-64-s.png"><img alt="_images/100ppm-64-s.png" src="_images/100ppm-64-s.png" style="width: 100%;" /></a>
<p class="caption">conversion to slightly faster clock, 64 x upsampling</p>
</div>
</div>
</div>
<div class="section" id="continuous-api">
<h2>Continuous API<a class="headerlink" href="#continuous-api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id2">
<h3>Functions<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="asrcContinuousBuffer">
void <tt class="descname">asrcContinuousBuffer</tt><big>(</big>int<em>&nbsp;sample</em>, struct <a class="reference internal" href="#asrcState" title="asrcState"><span>asrcState</span></a><em>&nbsp;&amp;state</em><big>)</big><a class="headerlink" href="#asrcContinuousBuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>UNTESTED Continuous interface to ASRC: add a sample to the buffer.</p>
<p>This must be called once for every input sample. Occasionally an extra or missing call to <a class="reference internal" href="#asrcContinuousInterpolate" title="asrcContinuousInterpolate"><span>asrcContinuousInterpolate()</span></a> compensates for the asynchronous nature</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sample</strong> &#8211; current sample value.</li>
<li><strong>state</strong> &#8211; buffer structure containing past sample values for interpolation</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="asrcContinuousInterpolate">
int <tt class="descname">asrcContinuousInterpolate</tt><big>(</big>int<em>&nbsp;frac</em>, struct <a class="reference internal" href="#asrcState" title="asrcState"><span>asrcState</span></a><em>&nbsp;&amp;state</em><big>)</big><a class="headerlink" href="#asrcContinuousInterpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>UNTESTED Continous interface to ASRC: called once for each sample to be produced on the output stream.</p>
<p>The value is computed given the previous ASRC_ORDER samples in the buffer that have been added with <a class="reference internal" href="#asrcContinuousBuffer" title="asrcContinuousBuffer"><span>asrcContinuousBuffer()</span></a>. An interpolated value is returned, notionally between ASRC_ORDER+1 and ASRC_ORDER samples in the past. A fractional value of 0.0 indicates sample ASRC_ORDER+1 in the past, 1.0 indicates ASRC_ORDER samples in the past, 0.5 a value exactly inbetween, etc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>frac</strong> &#8211; fractional sample - a number between 0 and 1 inclusive, where 1 is represented by ASRC_UPSAMPLING.</li>
<li><strong>state</strong> &#8211; buffer structure containing past sample values for interpolation</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the interpolated sample value.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id3">
<h3>Example<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="id4">
<h3>Performance<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>The interpolate function always performs a low pass filter,
which requires computation linear in ASRC_ORDER. The Buffer function is to
be called zero, twice, or once during this period; depending on whether the
fraction went above one, below zero, or stayed between 0 and 1. As an
indication, when ASRC_ORDER = 4, the worst case execution path is ...</p>
</div>
<div class="section" id="id5">
<h3>Distortion<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>Below we show the frequency analysis of a 1kHz sinewave that has been sped
up using the Asynchronous Sample Rate converter using the <em>continuous</em>
interface. Upsampling rates are between 64 and 250, and filters of orders
4, 8, and 16. This experiment used a 48 kHz sample rate at 24 bits.</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/100ppm-256-c.png"><img alt="_images/100ppm-256-c.png" src="_images/100ppm-256-c.png" style="width: 100%;" /></a>
<p class="caption">conversion to slightly faster clock, 256 x upsampling</p>
</div>
<div class="figure">
<a class="reference internal image-reference" href="_images/100ppm-128-c.png"><img alt="_images/100ppm-128-c.png" src="_images/100ppm-128-c.png" style="width: 100%;" /></a>
<p class="caption">conversion to slightly faster clock, 128 x upsampling</p>
</div>
<div class="figure">
<a class="reference internal image-reference" href="_images/100ppm-64-c.png"><img alt="_images/100ppm-64-c.png" src="_images/100ppm-64-c.png" style="width: 100%;" /></a>
<p class="caption">conversion to slightly faster clock, 64 x upsampling</p>
</div>
</div>
</div>
</div>



          </div>
        </div>
      </div>
      <div class="sphinxsidebar" id='d2'>
        <div class="sphinxsidebarwrapper">
<h3><a href="index.html">Documentation</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="summary.html">DSP Filtering</a></li>
<li class="toctree-l1"><a class="reference internal" href="biquad.html">module_cascading_biquad</a></li>
<li class="toctree-l1"><a class="reference internal" href="fir.html">Using FIR filters</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">module_asrc</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#general-api">General API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#configuration-defines">Configuration defines</a></li>
<li class="toctree-l3"><a class="reference internal" href="#types">Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#functions">Functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#simple-api">Simple API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example">Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#performance">Performance</a></li>
<li class="toctree-l3"><a class="reference internal" href="#distortion">Distortion</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#continuous-api">Continuous API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">Performance</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">Distortion</a></li>
</ul>
</li>
</ul>
</li>
</ul>

<div id="searchbox" style="display: none;margin-bottom: 10px;">
  <h3>Search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>



    <div class="footer">
    </div>
  </body>
</html>



